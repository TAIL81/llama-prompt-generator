import logging
import os
from dataclasses import dataclass
from functools import lru_cache
from typing import Dict, List, Mapping, Optional, Union

import groq
from dotenv import load_dotenv
from groq import Groq
from groq.types.chat.chat_completion_message_param import ChatCompletionMessageParam

from rater import Rater

# 環境変数を読み込みます
load_dotenv()

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)

# --- 定数定義 ---
# プロンプトテンプレートを共通化
BASE_PROMPT_TEMPLATE = """
You are a instruction engineer. Your task is to rewrite the initial instruction in <instruction> xml tag based on the suggestions in the instruction guide in <guide> xml tag.

Instruction guide:
<guide>
{guide}
</guide>

You are a instruction engineer. Your task is to rewrite the initial instruction in <instruction> xml tag based on the suggestions in the instruction guide in <guide> xml tag.
which is included using double pointed brackets is customizable text that will be replaced at runtime. This needs to be kept as is.
Please same language as the initial instruction for rewriting.

<instruction>
{initial}
</instruction>
""".strip()

EXAMPLE_TEMPLATE = """
<example>
{demo}
</example>
""".strip()

# --- データクラス ---
@dataclass
class GroqConfig:
    rewrite_model: str = "meta-llama/llama-4-scout-17b-16e-instruct"
    max_tokens: int = 8192
    temperature: float = 0.7

# --- 初期化処理 ---
current_script_path = os.path.dirname(os.path.abspath(__file__))
prompt_guide_path = os.path.join(current_script_path, "PromptGuide.md")

@lru_cache(maxsize=1)
def load_prompt_guide(path: str) -> str:
    """PromptGuide.md ファイルを読み込み、キャッシュします。"""
    with open(path, "r", encoding="utf-8") as f:
        return f.read()

PromptGuide = load_prompt_guide(prompt_guide_path)

groq_api_key: Optional[str] = os.getenv("GROQ_API_KEY")
if not groq_api_key:
    logging.error("GROQ_API_KEY環境変数が設定されていません。")
    raise ValueError("GROQ_API_KEY環境変数が設定されていません。")
groq_client = Groq(api_key=groq_api_key)

# --- メインクラス ---
class APE:
    def __init__(self) -> None:
        self.rater = Rater()
        self.config = GroqConfig()

    async def __call__(
        self, initial_prompt: str, epoch: int, demo_data: Dict[str, str]
    ) -> Mapping[str, Union[str, None]]:
        """APE処理を実行します。"""
        self._validate_inputs(initial_prompt, demo_data)

        candidates: List[str] = []
        for _ in range(2):
            rewritten_prompt: Optional[str] = self.rewrite(initial_prompt)
            if rewritten_prompt:
                candidates.append(rewritten_prompt)

        if not candidates:
            logging.error("Initial prompt rewriting failed for all attempts.")
            return {"prompt": initial_prompt, "error": "Initial prompt rewriting failed."}

        candidate_dicts: List[Dict[str, str]] = [{"prompt": c} for c in candidates]
        customizable_variable_list: List[str] = list(demo_data.keys())
        filtered_candidates: List[Dict[str, str]] = [
            c for c in candidate_dicts if all(var in c["prompt"] for var in customizable_variable_list)
        ]

        if not filtered_candidates:
            logging.warning("No candidates left after filtering for customizable variables.")
            candidates_log_str = "\n".join(f"--- Candidate {i+1} ---\n{c}" for i, c in enumerate(candidates))
            logging.warning(f"The following candidates were filtered out:\n{candidates_log_str}")
            return {
                "prompt": initial_prompt,
                "error": "No valid candidates after filtering. The rewritten prompts might be missing some required variables.",
            }

        logging.info("Rating initial candidates generated by APE.rewrite...")
        best_candidate_idx: Optional[int] = await self.rater(initial_prompt, filtered_candidates, demo_data)
        logging.info(f"Initial rating completed. Best candidate index: {best_candidate_idx}")

        if best_candidate_idx is not None and 0 <= best_candidate_idx < len(filtered_candidates):
            best_candidate_obj = filtered_candidates[best_candidate_idx]
        else:
            best_candidate_obj = filtered_candidates[0]
            logging.warning("Rater returned invalid index or failed, using first candidate as fallback.")

        for i in range(epoch):
            more_candidate_prompt: Optional[str] = self.generate_more(initial_prompt, best_candidate_obj["prompt"])
            if more_candidate_prompt:
                current_rating_candidates: List[Dict[str, str]] = [best_candidate_obj, {"prompt": more_candidate_prompt}]
                logging.info(f"Rating candidates in epoch {i+1}: [current_best vs new_generated]")
                rated_idx_loop: Optional[int] = await self.rater(initial_prompt, current_rating_candidates, demo_data)
                logging.info(f"Epoch {i+1} rating completed. Winning index: {rated_idx_loop}")

                if rated_idx_loop is not None:
                    best_candidate_obj = current_rating_candidates[rated_idx_loop]
                else:
                    logging.warning(f"Rater failed in epoch {i+1}. Keeping previous best candidate.")
            else:
                logging.warning(f"generate_more failed in epoch {i+1}. Keeping previous best candidate.")

        self._log_final_candidate(best_candidate_obj)
        return best_candidate_obj

    def _validate_inputs(self, initial_prompt: str, demo_data: Dict[str, str]) -> None:
        """入力パラメータの検証を行います。"""
        if not initial_prompt.strip():
            raise ValueError("初期プロンプトが空です")
        if not demo_data:
            logging.warning("デモデータが提供されていません。APEの実行に影響する可能性があります。")

    def _log_final_candidate(self, candidate: Dict[str, str]) -> None:
        """最終的な候補をデバッグログに出力します。"""
        logging.debug("APE.__call__ return:")
        for key, value in candidate.items():
            logging.debug(f"  {key}:")
            if isinstance(value, str):
                for line in value.splitlines():
                    logging.debug(f"    {line}")
            else:
                logging.debug(f"    {value}")

    def _call_groq_api(self, messages: List[ChatCompletionMessageParam], method_name: str) -> Optional[str]:
        """Groq APIを呼び出し、エラーハンドリングを共通化します。"""
        try:
            completion = groq_client.chat.completions.create(
                model=self.config.rewrite_model,
                messages=messages,
                max_completion_tokens=self.config.max_tokens,
                temperature=self.config.temperature,
            )
            result = completion.choices[0].message.content or ""
            if result.startswith("<instruction>"):
                result = result[13:]
            if result.endswith("</instruction>"):
                result = result[:-14]
            result = result.strip()
            logging.info(f"APE.{method_name} successful, result: \n{result}\n")
            return result
        except groq.InternalServerError as e:
            error_message = e.body.get("error", {}).get("message", str(e)) if hasattr(e, "body") and isinstance(e.body, dict) else str(e)
            logging.error(f"APE.{method_name} - Groq InternalServerError: {error_message} (Details: {e})")
            return None
        except groq.APIError as e:
            error_message = e.body.get("error", {}).get("message", str(e)) if hasattr(e, "body") and isinstance(e.body, dict) else str(e)
            logging.error(f"APE.{method_name} - Groq APIError: {error_message} (Details: {e})")
            return None
        except Exception as e:
            logging.error(f"APE.{method_name} - Unexpected error: {e}")
            return None

    def rewrite(self, initial_prompt: str) -> Optional[str]:
        """初期プロンプトをInstruction guideに基づいて書き換えます。"""
        prompt = BASE_PROMPT_TEMPLATE.format(guide=PromptGuide, initial=initial_prompt)
        messages: List[ChatCompletionMessageParam] = [{"role": "user", "content": prompt}]
        return self._call_groq_api(messages, "rewrite")

    def generate_more(self, initial_prompt: str, example: str) -> Optional[str]:
        """初期プロンプトと既存の良い例を基に、さらにプロンプト候補を生成します。"""
        prompt_with_example = f"{BASE_PROMPT_TEMPLATE}\n\n{EXAMPLE_TEMPLATE}".format(
            guide=PromptGuide, initial=initial_prompt, demo=example
        )
        final_prompt = f"{prompt_with_example}\n\nPlease only output the rewrite result."
        messages: List[ChatCompletionMessageParam] = [{"role": "user", "content": final_prompt}]
        return self._call_groq_api(messages, "generate_more")

