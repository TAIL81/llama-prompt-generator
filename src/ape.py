import logging
import os
from dataclasses import dataclass
from functools import lru_cache
from typing import Dict, List, Mapping, Optional, Union

import groq
from dotenv import load_dotenv  # 環境変数をロードするためのライブラリ
from groq import Groq  # Groq APIクライアント
from groq.types.chat.chat_completion_message_param import (
    ChatCompletionMessageParam,
)  # チャット補完メッセージの型ヒント

from rater import Rater  # Raterクラスをインポート

# 環境変数を読み込みます
load_dotenv()

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)

# --- 定数定義 ---
# プロンプトテンプレートを共通化
BASE_PROMPT_TEMPLATE = """
You are a instruction engineer. Your task is to rewrite the initial instruction in <instruction> xml tag based on the suggestions in the instruction guide in <guide> xml tag.

Instruction guide:
<guide>
{guide}
</guide>

You are a instruction engineer. Your task is to rewrite the initial instruction in <instruction> xml tag based on the suggestions in the instruction guide in <guide> xml tag.
which is included using double pointed brackets is customizable text that will be replaced at runtime. This needs to be kept as is.
Please same language as the initial instruction for rewriting.

<instruction>
{initial}
</instruction>
""".strip()

EXAMPLE_TEMPLATE = """
<example>
{demo}
</example>
""".strip()


# --- データクラス ---
@dataclass
class GroqConfig:
    rewrite_model: str = "moonshotai/kimi-k2-instruct"
    max_tokens: int = 8192  # 生成される応答の最大トークン数
    temperature: float = 0.7  # 応答の多様性を制御する温度パラメータ


# --- 初期化処理 ---
current_script_path = os.path.dirname(os.path.abspath(__file__))
prompt_guide_path = os.path.join(current_script_path, "PromptGuide.md")


@lru_cache(maxsize=1)
def load_prompt_guide(path: str) -> str:
    """PromptGuide.md ファイルを読み込み、キャッシュします。"""  # PromptGuide.mdファイルを読み込む関数
    with open(path, "r", encoding="utf-8") as f:
        return f.read()


PromptGuide = load_prompt_guide(prompt_guide_path)  # プロンプトガイドの内容をロード

groq_api_key: Optional[str] = os.getenv("GROQ_API_KEY")
if not groq_api_key:  # Groq APIキーが設定されているか確認
    logging.error("GROQ_API_KEY環境変数が設定されていません。")
    raise ValueError("GROQ_API_KEY環境変数が設定されていません。")
groq_client = Groq(api_key=groq_api_key)


# --- メインクラス ---
class APE:
    def __init__(self) -> None:
        self.rater = Rater()
        self.config = GroqConfig()  # GroqConfigのインスタンスを作成

    async def __call__(
        self, initial_prompt: str, epoch: int, demo_data: Dict[str, str]
    ) -> Mapping[str, Union[str, None]]:
        """APE処理を実行します。"""  # APE (Automatic Prompt Engineering) のメイン実行関数
        self._validate_inputs(initial_prompt, demo_data)

        candidates: List[str] = []
        for _ in range(2):
            rewritten_prompt: Optional[str] = self.rewrite(initial_prompt)
            if rewritten_prompt:
                candidates.append(rewritten_prompt)
        # 候補が生成されなかった場合のエラーハンドリング
        if not candidates:
            logging.error("Initial prompt rewriting failed for all attempts.")
            return {
                "prompt": initial_prompt,
                "error": "Initial prompt rewriting failed.",
            }

        candidate_dicts: List[Dict[str, str]] = [
            {"prompt": c} for c in candidates
        ]  # 候補プロンプトを辞書形式に変換
        customizable_variable_list: List[str] = list(
            demo_data.keys()
        )  # カスタマイズ可能な変数リスト
        filtered_candidates: List[Dict[str, str]] = [
            c  # カスタマイズ可能な変数がすべて含まれている候補のみをフィルタリング
            for c in candidate_dicts
            if all(var in c["prompt"] for var in customizable_variable_list)
        ]

        if not filtered_candidates:
            logging.warning(
                "No candidates left after filtering for customizable variables."
            )
            candidates_log_str = "\n".join(
                f"--- Candidate {i+1} ---\n{c}" for i, c in enumerate(candidates)
            )
            logging.warning(
                f"The following candidates were filtered out:\n{candidates_log_str}"
            )
            return {
                "prompt": initial_prompt,
                "error": "No valid candidates after filtering. The rewritten prompts might be missing some required variables.",
            }

        logging.info(
            "Rating initial candidates generated by APE.rewrite..."
        )  # 初期候補の評価を開始
        best_candidate_idx: Optional[int] = await self.rater(
            initial_prompt, filtered_candidates, demo_data
        )
        logging.info(
            f"Initial rating completed. Best candidate index: {best_candidate_idx}"
        )

        if best_candidate_idx is not None and 0 <= best_candidate_idx < len(
            filtered_candidates
        ):
            best_candidate_obj = filtered_candidates[best_candidate_idx]
        else:
            best_candidate_obj = filtered_candidates[0]
            logging.warning(
                "Rater returned invalid index or failed, using first candidate as fallback."  # Raterが不正なインデックスを返した場合のフォールバック
            )

        for i in range(epoch):
            more_candidate_prompt: Optional[str] = self.generate_more(
                initial_prompt, best_candidate_obj["prompt"]
            )
            if more_candidate_prompt:
                current_rating_candidates: List[Dict[str, str]] = [
                    best_candidate_obj,
                    {
                        "prompt": more_candidate_prompt
                    },  # 現在の最良候補と新しく生成された候補を比較
                ]
                logging.info(
                    f"Rating candidates in epoch {i+1}: [current_best vs new_generated]"
                )
                rated_idx_loop: Optional[int] = await self.rater(
                    initial_prompt, current_rating_candidates, demo_data
                )
                logging.info(
                    f"Epoch {i+1} rating completed. Winning index: {rated_idx_loop}"
                )

                if rated_idx_loop is not None:
                    best_candidate_obj = current_rating_candidates[rated_idx_loop]
                else:
                    logging.warning(  # Raterが失敗した場合の警告
                        f"Rater failed in epoch {i+1}. Keeping previous best candidate."
                    )
            else:
                logging.warning(
                    f"generate_more failed in epoch {i+1}. Keeping previous best candidate."
                )

        self._log_final_candidate(best_candidate_obj)
        return best_candidate_obj

    def _validate_inputs(self, initial_prompt: str, demo_data: Dict[str, str]) -> None:
        """入力パラメータの検証を行います。"""  # 入力検証関数
        if not initial_prompt.strip():
            raise ValueError("初期プロンプトが空です")
        if not demo_data:  # デモデータが空の場合の警告
            logging.warning(
                "デモデータが提供されていません。APEの実行に影響する可能性があります。"
            )

    def _log_final_candidate(self, candidate: Dict[str, str]) -> None:
        """最終的な候補をデバッグログに出力します。"""
        logging.debug("APE.__call__ return:")
        for key, value in candidate.items():
            logging.debug(f"  {key}:")
            if isinstance(value, str):
                for line in value.splitlines():
                    logging.debug(f"    {line}")
            else:
                logging.debug(f"    {value}")

    def _call_groq_api(
        self,
        messages: List[ChatCompletionMessageParam],
        method_name: str,  # Groq API呼び出しの共通化
    ) -> Optional[str]:
        """Groq APIを呼び出し、エラーハンドリングを共通化します。"""
        try:
            completion = groq_client.chat.completions.create(
                model=self.config.rewrite_model,
                messages=messages,
                max_completion_tokens=self.config.max_tokens,  # 最大トークン数を設定
                temperature=self.config.temperature,
            )
            result = completion.choices[0].message.content or ""
            if result.startswith("<instruction>"):
                result = result[13:]
            if result.endswith("</instruction>"):
                result = result[:-14]
            result = result.strip()
            logging.info(
                f"APE.{method_name} successful, result: \n{result}\n"
            )  # 成功時のログ出力
            return result
        except groq.InternalServerError as e:
            error_message = (
                e.body.get("error", {}).get("message", str(e))
                if hasattr(e, "body") and isinstance(e.body, dict)
                else str(e)
            )
            logging.error(
                f"APE.{method_name} - Groq InternalServerError: {error_message} (Details: {e})"
            )  # 内部サーバーエラーのログ出力
            return None
        except groq.APIError as e:
            error_message = (
                e.body.get("error", {}).get("message", str(e))
                if hasattr(e, "body") and isinstance(e.body, dict)
                else str(e)
            )
            logging.error(
                f"APE.{method_name} - Groq APIError: {error_message} (Details: {e})"
            )  # APIエラーのログ出力
            return None
        except Exception as e:
            logging.error(
                f"APE.{method_name} - Unexpected error: {e}"
            )  # その他の予期せぬエラーのログ出力
            return None

    def rewrite(self, initial_prompt: str) -> Optional[str]:
        """初期プロンプトをInstruction guideに基づいて書き換えます。"""  # プロンプト書き換え関数
        prompt = BASE_PROMPT_TEMPLATE.format(guide=PromptGuide, initial=initial_prompt)
        messages: List[ChatCompletionMessageParam] = [
            {"role": "user", "content": prompt}
        ]
        return self._call_groq_api(messages, "rewrite")

    def generate_more(self, initial_prompt: str, example: str) -> Optional[str]:
        """初期プロンプトと既存の良い例を基に、さらにプロンプト候補を生成します。"""
        prompt_with_example = f"{BASE_PROMPT_TEMPLATE}\n\n{EXAMPLE_TEMPLATE}".format(
            guide=PromptGuide, initial=initial_prompt, demo=example
        )
        final_prompt = (
            f"{prompt_with_example}\n\nPlease only output the rewrite result."
        )
        messages: List[ChatCompletionMessageParam] = [
            {"role": "user", "content": final_prompt}
        ]
        return self._call_groq_api(messages, "generate_more")
